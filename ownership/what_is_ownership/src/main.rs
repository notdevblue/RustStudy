// https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html

/*
Rust에서 메모리 메니지먼트는 컴파일러 규칙을 통해 확인하는 오너쉽 시스템을 사용함.
규칙에 만족하지 않으면, 프로그램은 컴파일되지 않음
오너쉽 기능은 퍼포먼스 저하 주지 않음.

값이 stack 에 있냐, heap 에 있냐에 따라 언어의 행동이 달라짐

stack과 heap 코드가 실행하면서 사용이 가능한 메모리의 부분들임
하지만 서로간의 구조는 다름

## stack
stack은 (stack 자료 구조) stack 처럼 메모리가 저장되고 삭제됨
last in first out (first in last out) 구조

stack에 데이터를 넣는 것은 pushing onto the stack (스택에 밀어 넣는다)
stack에 데이터를 빼는 것은 popping off thet stack (스택에서 튀어 나오다)

stack에 들어가는 데이터들의 사이즈들은 알수 있고, 고정되있어야 함.
컴파일 시간에 데이터의 크기를 알수 없거나, 데이터의 크기가 변경이 될 가능성이 있다면 heap에 들어가야 함

## heap

heap은 덜 정리되어 있음.
heap에 데이터를 넣게 되면, 어떤 특정한 크기의 공간을 요청하게 됨.
메모리 할당자 (memory allocator) 는 특정한 크기 만큼의 큰 공간을 찾은 뒤, 사용중으로 표시해두고, 그 공간을 가리키는 포인터를 반환함. (int* myArray = new int[100]; 같은 느낌)
이 프로세스는 allocating on the heap (heap 에 할당한다)이라고 함. 그리고 가끔 allocating(할당한다) 이라고도 불림 (stack에 데이터 푸쉬하는건 allocating 이라고 안함)

heap을 가리키는 포인터의 크기는 알수 있고, 고정되있기 때문에 stack에 저장할 수 있음.
하지만 실제 데이터를 원하는 경우, 반드시 포인터를 따라가야 함.

레스토랑에 들어간다고 생각하면 편함.
레스토랑에 들어간 뒤, 몇명인지 알려주면, 직원이 방문한 인원이 모두 앉을 수 있는 빈 테이블을 찾고 안내해 줄 거임.
그리고, 누군가가 늦게 도착했다면, 직원을 통해 아까 온 사람들이 어디에 앉아있는지 물어볼 수 있음.

## speed (performance)

heap에 있는 데이터에 접근하는 것은 stack에 있는 데이터에 접근하는 것보다 느림.
heap에 있는 데이터를 접근하기 위해서는 pointer를 통해 접근해야 하기 때문임.

요츰 프로세서 (cpu)는 메모리에서 적게 이동할수록 빠름.
위에 예시에서 이어가자면, 직원이 레스토랑에서 주문을 받는다고 생각하는거임.
제일 효율적인 것은, 한 테이블에서 한번에 주문을 다 받고, 다음 테이블에 가서 주문을 받는 거임.
A 테이블에서 주문을 받고, B 테이블에서 주문을 받고, 다시 A 테이블에 가서 주문을 받고, 또 B 테이블에 가는거는 아주 느릴거임.

같은 맥락으로, 프로세서는 데이터가 서로서로 가까이 있으면 더욱 빠르게 작동하고, (stack에 있는 그대로) 멀리 떨어저 있을 수록 느리게 작동함 (heap 에 있을수 있음)

## stack 과 function

코드에서 함수를 호출하는 경우, 함수에 전달된 값들과 함수 내부의 변수들은 stack 에 할당됨.
(heap에 있는 데이터를 가리킬 가능성이 있는 포인터도 포함됨)
함수의 실행이 끝나게 되면, 값들은 stack에서 튀어 나오게 됨.

## 마무리

코드의 어느 부분에서 heap에 있는 어떠한 데이터를 사용하는지 기억하는 것,
최대한 heap에서 중복된 데이터를 줄이는 것,
그리고 heap에서 사용되지 않는 데이터를 삭제하여 메모리에 빈 공간을 확보하는 것들은 ownership이 담당하는 부분임.

ownership을 이해하고 나면, stack과 heap에 대해 그리 자주 생각하지 않아도 됨.
하지만 ownership의 주 목적이 heap의 데이터를 관리한다는 것을 알게 되면, 왜 이런 방식으로 작동하는지 알기 쉬워질 것.
*/


// ownership rules
/*
* 러스트에서 각각의 값은 owner를 가지고 있음
* 한번의 하나의 owner만 존재할 수 있음
* owner가 스코프 밖으로 나가게 되면, 값은 삭제될 것임
*/

fn main() {
    {
        let mut _s = "Gentoo";
        // 대부분의 언어와 같은 스코프 작동 원리
        // 이 변수는 immutable
        // +, += 같은게 안 써짐
    }

    let mut s = String::from("Install Gentoo");
    // heap에 저장됨

    s.push_str(" and Remove Windows."); // string 에 리터럴 추가

    println!("{}", s);

    // 왜 String은 가능한데 리터럴은 불가능한 것인가?
    // 그것은 두가지의 타입이 메모리를 서로 다르게 사용하기 때문임.

    
}
